* If you've ever come across the Laravel framework, it's highly unlikely that you haven't heard of service
  containers and service providers. In fact, they're the backbone of the Laravel framework and do all the 
  heavy lifting when you launch an instance of any Laravel application.
  
* The Laravel service container is a powerful tool for managing class dependencies and performing dependency injection.

* default service providers are stored in the app/Providers directory

* Service providers are the central place to configure,register & boot setting your apps	 

* AppServiceProvider is fairly empty to configure service container bindings

* The boot() method is used to boot any routes, event listeners, or any other facades you want to add to your apps. 

  The register() method is used to bind any classes into the app container. 

* within the register method, you should only bind things & dependency injection into the service container




Create & Register Service Container :

step ->  


own class

service provider 

register custom class in provider

create facade & return facade name

add facade & provider in service container


 		
-------------------



MyApp\MyApp.php :


<?php

namespace App\MyApp;

class MyApp {

    public function sayHello($data = [])
    {
        echo "Hello World from Facade!";
    }
	
}


------------------


php artisan make:provider MyAppServiceProvider


-----------------


ADD REGISTER METHOD TO SERVICE PROVIDER CLASS :


namespace App\Providers;

use Illuminate\Support\Facades\App;

use Illuminate\Support\ServiceProvider;


class MyAppServiceProvider extends ServiceProvider{

    public function register(){
	
		// serive container
	
        App::bind('myapp', function(){		// myapp here alias
		
            return new \App\MyApp\MyApp;  	//(folder\folder\filename)
			
        });
		
    }
	
}


-----------------


// facade is a helper class. its create for get into complicated call


	App\Facades\MyApp.php


	namespace App\Facades;

	use Illuminate\Support\Facades\Facade;

	class MyApp extends Facade{

		protected static function getFacadeAccessor(){ 
		
			return 'myapp'; 						// need to call myapp when access myapp::methodname()
		
		}
		
	}



-----------------


Add service provider

App\Providers\MyAppServiceProvider::class,



Add alias

'MyApp' => App\Facades\MyApp::class



-----------------


TESTING in route :

MyApp::sayHello();



TESTING in controller :

use App\Facades\MyApp;

MyApp::sayHello();







** SOFTWARE DEVELOPMENT 






1. software process model :

	* which work will do first & which will last
	
	* timing & next step descripe on this model
	
	
2. waterfall model :

	project accept -> requirement analysic -> architec design -> detail design -> coding -> testing
  
  
  
  
  
  
  
DESIGN PATTERN :





** Design pattern make your code easy , simple , fast & secure

Some patterns are developed by senior developer :


1. Strategy Pattern :

   * 3 part -> who will send , what will send , how will send
   
   * target simply make your code dynamic. 
   
   Design :
   
		 
		
														1. SendMail
			
	User class		->notification interface		->	2. SendFax
		
														3. SendSMS
														
											
	* We have user . user will send notification.
	
	* in notification class we will decide what we will send.
	
	* in mail fax & sms we have sending functionality
	
	
2. Decorator Pattern :

	* Insert any method value without touch main class. 
	
	* Empty interface Class then full assign data in impliment
	
	
				pizza class with cost & name
						
						->
	
				Pizza_container interface class . impliment here pizza class.
				

3.  Facade Pattern :

	* easy way to access into complicated location class.
	
											ssc
											
	dhaka class ->	education			->	university
	
											phd
											
											
	* make 3 object of 3 class in education. then access it from dhaka.
	
	
4. factory pattern :

	* when object create depends on outside condition.

		like mysqliclass | oracleclass
			
		if host mysqli then mysqliclass will run otherwise oracleclass will run

5. Abstract is overwrite for child class.

6. singleton is check by static variable. if already created go to else.










SERVICE PROVIDER :








* custom service provider need for create packages. otherwise no need. it will define what will run in register & boot

* service container is binding something in boot method


Service Provider class we have 2 methods boot() and register(). 

The boot() method is used to boot any routes, event listeners, or any other functionality you want to add to your package. 

The register() method is used to bind any classes or functionality into the app container.


* i have a class. i want to use it. just create it in app/library then create a service provider for register it. in register method, 
  you should only bind service provider with service container & in boot part define which composer you want in your class. like route, view etc.	

* To register your service provider, you just need to add an entry to the array of service providers in the service container config/app.php file

* Boot : if we need any composer in our service provider. like routes , views . we need to register this in boot.
		


step ->  


own class

service provider 

register custom class in provider

create facade & return facade name

add facade & provider in service container


 		
-------------------



MyApp\MyApp.php :


<?php

namespace App\MyApp;

class MyApp {

    public function sayHello($data = [])
    {
        echo "Hello World from Facade!";
    }
	
}


------------------


php artisan make:provider MyAppServiceProvider


-----------------


ADD REGISTER METHOD TO SERVICE PROVIDER CLASS :


namespace App\Providers;

use Illuminate\Support\Facades\App;

use Illuminate\Support\ServiceProvider;


class MyAppServiceProvider extends ServiceProvider{

    public function register(){
	
        App::bind('myapp', function(){		// myapp here alias
		
            return new \App\MyApp\MyApp;  	//(folder\folder\filename)
			
        });
		
    }
	
}


-----------------


// facade is a helper class. its create for get into complicated call


	App\Facades\MyApp.php


	namespace App\Facades;

	use Illuminate\Support\Facades\Facade;

	class MyApp extends Facade{

		protected static function getFacadeAccessor(){ 
		
			return 'myapp'; 						// need to call myapp when access myapp::methodname()
		
		}
		
	}



-----------------


Add service provider

App\Providers\MyAppServiceProvider::class,



Add alias

'MyApp' => App\Facades\MyApp::class



-----------------


TESTING in route :

MyApp::sayHello();



TESTING in controller :

use App\Facades\MyApp;

MyApp::sayHello();








KEYWORD :







* namespace route : access folder for controller

* prefix route : need to add this before route

* closer - type hinting

* middleware - checkpost . run after every url request.

* karnel - after create register middleware here.

			 have 3 part : 

			 protected middleware: hit all route 
		 
			 route middlware : hit only specific route 	


* php artisan serve : for run the project from remote location

* public directory : contain htaccess. index.php autoload all function.

* Application Key : php artisan key:generate command . use for sessions and other encrypted data be secure!

* @section directive : as the name implies, defines a section of content,

* @yield directive is used to display the contents of a given section

* MIMES - MIME (Multi-Purpose Internet Mail Extensions) is an extension of the original 
          Internet e-mail protocol that lets people use the protocol to exchange 
		  different kinds of data files on the Internet: audio, video, images, 
		  application programs, and other kinds,

* config/app - where we can register our own provider.

* config/auth.php - register your authentication here.

* service container - Service providers are the central place to configure your service provider. service container is collection of built in provider . location config/app.php.
		   
* serive provider - Service providers are the central place to configure your own class	   

* app service provider - laravel have build in service provider. you can overwrite here all there build in service provider. boot is overwrite register is for register new service provider.registering things, including registering service container bindings, event listeners, middleware, and even routes. Service providers are the central place to configure your application.

* facade - facade is simple method to access complicated class. view route 

* Schema::defaultStringLength(191) - Laravel uses the utf8mb4 character set by default, which includes support for storing "emojis" in the database. If you are running a version of MySQL older than the 5.7.7 release or MariaDB older than the 10.2.2 release, you may need to manually configure the default string length generated by migrations in order for MySQL to create indexes for them. You may configure this by calling the  Schema::defaultStringLength method within your AppServiceProvider

* seeder - 

	use for insert demo data in database. large amount 30 
	
	php artisan make:seeder UsersTableSeeder
	
	for insert : php artisan db:seed

	
* dask - laravel dask act like javascript event & selector. you can do all js onmouseover or bla bla here in php way.
          that means it will load browser then it will work.

          https://www.youtube.com/watch?v=V75hPsS6cvk

* redis - database store . support nosql

* scout - use for search pakage. it use angolia search system.

* cashier - use for payment getway pakage

* elequest vs query builder - 

                         elequnt like active record. secuire but slow. no need to learn sql
						 query builder is fast. best for sql user.
 

* maiable - class for send mail

* factory - its a function which have object name faker. use for generate random data & Seed will insert this data.

 Factory | Seed | Faker 

   * factory is for generate fake data & faker is a object of facetory.

   * php artisan make:factory ModelNameFacetory --model=ModelName (ModelName here is in which table we want to insert data)
   
   * It will generate a folder in confiq/database/factory
   
   return [
	
		'name' => 		$faker->name,
        'email' => 		$faker->email,
        'password' => 	bcrypt('secret'),
						$faker->randomDigit;
						$faker->numberBetween(1,100);
						$faker->word;
						$faker->paragraph;
						$faker->lastName;
						$faker->city;
						$faker->year;
						$faker->domainName;
						$faker->creditCardNumber;
						$faker->region;
						$faker->bankAccountNumber;
						$faker->cellNumber;
   ]

* notification - its a class . can create & call when a out come need of any work. have mail or sms notification.

* session - configure in config/session.php .  sessions are stored in storage/framework/sessions

* passport - api create package

* policy 

* request - where we make rule

* autoload :

	in composer.json 
	
	"autoload":{
	
		// classmap is anything is this namespace
	
		classmap :[
			"app/foldername",
			"app/another_foldername"
		],
		
		// this file will be autooaded
	
		files :[
			"app/filename.php",
		],
	
	}
	
* psr : for autoload a file we can use psr. we can set path in 2 way.

	laravel use psr-4
	
	psr 0 & psr 4 :
	
	1. 	For example if you define that the Acme\Foo\ namespace is anchored in src/,
		with PSR-0 it means it will look for Acme\Foo\Bar in src/Acme/Foo/Bar.php
		while in PSR-4 it will look for it in src/Bar.php.

	2. PSR-4 does not convert underscores to directory separators

	3. You cannot use PSR-4 if you do not use namespaces
	
	
	"psr-4": {
		"namespace\\": "directory"
	}
	
*  composer dump-autoload  :

	1. Composer dump-autoload won’t download a thing.
	2. It just regenerates the list of all classes that need to be included in the project (autoload_classmap.php).
	3. Ideal for when you have a new class inside your project.
	4. autoload_classmap.php also includes the providers in config/app.php
	
	
*  Session data is stored on the server. 
   A cookie with the session's ID is stored on the user's computer, 
   and is associated with a single domain name. 
   The browser passes this cookie to the server so it knows what session data to associate with the user.
   Two websites, hosted under the same domain, 
   are going to share the same session because there will only be one cookie containing a session ID. 
   If you put the websites under different domains, 
   you will no longer have the problem since two different cookies 
   (containing two different session ID's) will be made on the user's computer; one for each domain name.
   
   
*  Whoops error page

*  chunk vs get

	check -> bring from database data part by part. best for large data.
	
    $flight = App\Flight::all();
	$flight->get();

	get -> get all data from database.
	
	$flight = App\Flight::all();
	App\Flight::chunk(100);
	
	
*   dump() vs dd() :

    dump can set any point but dd will hit over full process.	
 
	dd(App\Flight::where('active', 1)->orderBy('name', 'desc')->take(10)->get());
	
	App\Flight::where('active', 1)->orderBy('name', 'desc')-dump()->take(10)->get();
	
	
*   create command line :

    php artisan make:command SayHello command=say:hello	
	

*  echo : Laravel Echo is a JavaScript library that makes it painless to subscribe to channels and listen for events broadcast by Laravel.
                                                                     
*  event listen : event for pass listern for catch.

* scafholding : The term Scaffolding roughly aims to a quickly set up skeleton for an app or your project.

				The main purpose of Scaffolding is to speed your workflow rather than creating it new. like make auth

* Resourse : for api create

* log file created when error ocured

* Semantic Versioning : github Semantic Versioning means verison 1.1.0 . 
				
						that means a if new version released must need to use it. 
						
						but non semantic gives you option for use old version.
		
						laravel use non sementic Versioning
						
				
* Installing Laravel : First, download the Laravel installer . then create project

* Local Development Server : for access from remote location

* Application Key need for If the application key is not set, your user sessions and other encrypted data will not be secure!

* .env.example for if any one in your group use ur project can set value here

* confiq/app .php  -> contain all classes

*  Routes ->

			web.php (all route list)
			
			api.php (set middleware here)
			
			
* soft delete is nothing but deleted_at column

* auto load any class

 {
    "autoload": {
        "classmap": [
            "database"
        ],
        "psr-4": {
            "App\\": "app/"
        }
    }
 }
 
 
 composer dump-autoload
 
 
 
* Lumen is PHP micro framework that built on Laravel’s top components

* csrftoken verify in app/http/middleware/csrf_token . turn off from there if you want.

  without csrf origin of that data is not. 
  
  
* function(Request $request)  [Request is here typehint $request is object]

* vendor folder contain all package

* ORM : Object-relational Mapping (ORM) is a programming technique for converting data between incompatible type systems in object-oriented programming languages.
  
        Its a model for connect oop with database & other program
		
* Laravel’s Eloquent ORM is one the most popular PHP ORM (OBJECT RELATIONSHIP MAPPING).
 
  It provides a beautiful, simple ActiveRecord implementation to work with your database.		
  
  elequent orm is model for connect with database.
  
* PSR-4 is autoloading standard. laravel use it.

   app/http/controller
   
* in apps folder we have middleware controller model

* The Console Directory have all php artisan commad for us

* The Http directory contains your controllers, middleware, and form requests.

* The Providers directory contains all of the service providers for your application. Service providers bootstrap your application by binding services

* Cross-site request forgery, also known as one-click attack or session riding and abbreviated as CSRF

* <meta name="csrf-token" content="{{ csrf_token() }}"> for use csrf for full page

* Lifecycle Overview :


1. The Loading Steps :

	* first load public/index.php This file loads vendor/autoload.php , bootstrap/app.php

	
		* bootstrap/app.php bind kernels into the service container,
	  
		  because its incoming requests to this application from both the web and CLI
	
			*The kernel will receive the request, load the service providers and will be redirected to router.
			
			 (Any Service Providers you've created or linked into your application are loaded early in the boot process,
			
			 after boot method it load register method)
			 
			 
			
		* vendor/autoload.php load composer/autoload_real.php for run composer.json

		

index.php -> 	1. vendor/autoload.php

					-> composer.json

				2. bootstrap/app.php
				
					-> kernel.php
					
						-> service providers
						
							-> route.php
							
							-> disputch
							
							
* The App\Exceptions\Handler class is where all exceptions triggered by your application are logged 

* custom log file :

	app/congiq.php

   'log' => env('APP_LOG', 'daily'),  [create seperate log file for daily wise]
   
   'log' => env('APP_LOG', 'single'),  [create all log file in single file]
   
   
   
   
   'name' => env('APP_NAME', 'Laravel'), [this app name used when initailize with package]
   
   'debug' => env('APP_DEBUG', false),   [for use 404 error turn it false. if true 404 not work]
   
  

	'fallback_locale' => 'en', 			  [its for multi languages, set language is views/resourse/lang]
	
	
	
   
* All exceptions are handled by the App\Exceptions\Handler class

	report method : The report method is used to log exceptions or send them to an external service like Bugsnag or Sentry.
	
	
* vendor language change :

  resources/lang/vendor/vendor_name/en/messages.php
  
  
* php artisan preset none  (use for remove css file. make built in css file empty, for our work)

* guzzle allow http request external
