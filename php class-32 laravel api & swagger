
Need to develop :
https://laravel-news.com/json-api-introduction
Api crud : https://www.toptal.com/laravel/restful-laravel-api-tutorial

 Rest API - StateLess (Allow different network)- XML & JSON - 

 Soap API - Statefull (Dont allow different network) - XML - After match ending xml data push
 
 soap:Envelope -> header & body

 Simple Object Access Protocol
 
 Representational State Transfer
 
 Collections (collection of resource) - Resource (model) -  - URL

   resource should always be plural

   Sorting, filterning, searching, pagination, version set


LETS START ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


First we need to generate 2 classes one to handle the resource and the other to handle the collection.

*** Make resource : php artisan make:resource ArticleResource

*** Make collection of that resource : php artisan make:resource ArticlesResource --collection


You will now have a new directory under app/Http/Resources where all these resources will reside.

classes you will have a toArray method which is where we will transform our models the way we want them.

public function toArray($request){
	return [
	    'type'          => 'articles',
	    'id'            => (string)$this->id,
	    'attributes'    => [
		'title' => $this->title,
	    ],
	];
}


*** Make comtroller : php artisan make:controller --resource ArticleController

Now wrap model in controller :::

public function show(Article $article)
{
    return new ArticleResource($article);
}


*** Route :

Route::resource('articles', 'ArticleController');






___________________________________


INSERT DATA FROM EXTERNAL API & INTO DATABASE :::::::::::::::::::::::::::::::::::

view OR insert into database

	$json = file_get_contents('http://echaritybd.com/api/users');

	$data = json_decode($json,true);

	echo "<pre>";

	print_r($data['data']);
	
	for($i=0;$i< count($data['data']);$i++){
		echo $data['data'][$i]['user_id'];
	}

	exit;

THEN _________________________________


API CREATE FOR USE in get method :::::::

Route::get('userPost', function() {

    $user = user::all();
    if(count($user) == 0){
       $feedback = [
           'status'     => "error",
           'message'    => "data not found",
           'data'       => null
        ];

    }else{
        $feedback = [
           'status'     => "success",
           'message'    => "data found",
           'data'       => $user
        ];
    }

    return $feedback;

});



API CREATE FOR single data in get method :::::::

Route::get('departments/{id}', function($id) 

create method for edit




_________________________________


INSERT API LINK FOR IN POST METHOD :::::::


Post:

Route::post('userPost', function(Request $request) {

    $user = new User;
    $user->data = $request->data;
    $result = $user->save();

    if(count($result) == 0){
       $feedback = [
           'status'     => "error",
           'message'    => "insert error"
        ];

    }else{
        $feedback = [
           'status'     => "success",
           'message'    => "inserted successfully"
        ];
    }

    return $feedback;

});

** must add 

protected $fillable = ['fieldname','fieldname']


______


UPDATE API LINK FOR IN UPDATE METHOD :::::::

Route::put('poll/{id}','control@method')


controller :

public function update(Request $request,$id) {

   $poll = DB::table('aps')
		->where('id',$id)
		->update(array(
			'name'=>$request->name,
		));

   if($poll == null){
       $feedback = [
	   'status'     => "error",
	   'message'    => "update error"
	]; 

    }else{
	$feedback = [
	   'status'     => "success",
	   'message'    => "update successfully"
	]; 
    }

    return $feedback;

}



______



UPDATE API LINK FOR IN DELETE METHOD :::::::


Delete :

Route::delete('poll/{id}','control@method')

controller :

public function delete(Request $request,$id) {

   $poll = DB::table('aps')
		->where('id',$id)
		->delete();

   if($poll == null){
       $feedback = [
	   'status'     => "error",
	   'message'    => "delete error"
	]; 

    }else{
	$feedback = [
	   'status'     => "success",
	   'message'    => "delete successfully"
	]; 
    }

    return $feedback;

}



:::::::::::::::::::::::::::::::


Validation for view (Only apply in edit):

$department = department::find($id);

if(is_null(ap::find($id))){
    $feedback = [
       'status'     => "error",
       'message'    => "data not found",
       'data'       => null
    ]; 
    return $feedback;
}else{
    $feedback = [
       'status'     => "success",
       'message'    => "data found",
       'data'       => ap::find($id)
    ]; 
    return $feedback;
}




:::::::::::::::::::::::::::::::


Validation for insert:


$validator = Validator::make($request->all(), [
	        
    'name'  => 'required'

]);

if ($validator->fails()) {

    return response()->json($validator->errors()->toArray(),400);
    
} else {

    $data = $request->all();
    return ap::create([
        'name' => $data['name']
    ]);

    if(count($data) == 0){
       $feedback = [
           'status'     => "error",
           'message'    => "insert error"
        ]; 

    }else{
        $feedback = [
           'status'     => "success",
           'message'    => "inserted successfully"
        ]; 
    }
}




::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


Perfect API with customize data:


* php artisan make:controller API/PhotoController --api (api controller)

* Route::apiResource('user','API\UserController'); (api route)

* must create model , fillable & migration 

* index method or UserController for check:
 
  return User::all();
  
  Now check : http://localhost/test/public/api/user

___

Now create resource for customize data:


* php artisan make:resource User/UserResource (resource for customize data)

* in controller:
  use App\Http\Resources\User\UserResource;

* in UserResource file:

   public function toArray($request)
    {
      //dd($this);
      
      return[
        'name' => $this[0]['name'] == "data" ? '0':'1',
      ];
    }



in controller :

* use App\Http\Resources\User\UserResource;
  
* return new UserResource($User); 
 




::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	
* Side loading | one to many relationship:

Question table : id title user_id** created_at updated_at
user table     : id name password created_at updated_at 

Select all post against single user.
One to many relationship

* In user model:

  public function fetchHasOneUser(){
      return $this->hasOne(Post::class);
  }

* In user controller:

  // fetch all post from passes user_id **
  
  public function show($id){
      $user = User::find($id)->fetchHasOneUser;
      $response['user'] = $user;
      return $response;
  }




::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 


API File show:


$user = User::find($id)->questionMethod;
$response['user'] = $user;
$response['download'] = public_path('files/'."a.png");
return $response;


on click link set download method:

return response->download(asset('imgae/a.png','Show name here'));


API File upload:

$cover_image = $request->file('photo');

$enc_cover_image = time() . '.' . $cover_image->getClientOriginalExtension();

$destinationPath = public_path('files');

$cover_image->move($destinationPath, $enc_cover_image);


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

 
Guzzle Token Check (for auth & view):

************

guzzle install:

composer require guzzlehttp/guzzle

---

// client side ---------------------------------------------
// set route for get data from remote api from client side

Route::get('Developerall','DeveloperController@getGuzzleRequest');


// set method & header for get data from remote api from client side

  public function getGuzzleRequest(Request $request){

      $client = new Client(['http_errors' => false]);
    	$allresponse = $client->request('GET','http://localhost/test/public/api/user', [
    	    // here Authorization fixed, check postman by bearer token
	    'headers' => [
    		'Authorization' => "Bearer 54rwerf345t3"
    	    ]
    	]);

      $allbody = $allresponse->getBody();

    	$all_list = json_decode($allbody->getContents(),true);
      // check response in here
      if($all_list[0] != "authorization error"){
    	   return view('view',compact('all_list'));
      }else{
        return $all_list;
      }
  }


// developer side here-----------------------------------------

// as a developer check api token header in public/api/user this route

public function index(Request $request)
{
// in developer side check header request from client
  $headers = $request->headers->all();
  $pubapi = $request->header('authorization_token');

// check header requset with database, if match send data
  if($pubapi != ""){
    $user =  User::all();
    return $user;
  }else{
    $feedback = ['authorization error'];
    return $feedback;
  }
}


// view for client --------------------------------------------

<?php foreach ($all_list as $key => $value) {
  echo $value['name'];
} ?>



::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 
 
 Oauth:
 
 https://github.com/armanhakimsagar/Oauth
 
 
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 
 Create API Here  -http://editor.swagger.io/

demo yml : https://gist.github.com/armanhakimsagar/3c733fea95cfa3f68903a12cbfe7d7dc
Then just export -> generate client -> html2 





 
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


Theory:


Web serice: 
  
  1. Web service is a standardized medium to propagate communication between the client and server applications on the World Wide Web.
  
  2. The only difference is that a Web service facilitates interaction between two machines over a network. XML
  
API:

  1. The only difference is that a Web service facilitates interaction between two machines over any network.
     JSON,XML

Type of Web Service:

  SOAP web services: 
  	SOAP is based on transferring XML data as SOAP Messages. Soap mainly used for transfer xml data.
	We can make any xml doucment like WSDL (Web services description language) for descripe XML details.
	
	SOAP was to ensure that programs built on different platforms and programming languages could exchange data in an easy manner
  
  	Statefull (web service does in addition to the location of the web service)
	
	No lack of Security
	
	An Envelope element that identifies the XML document as a SOAP message
	A Header element that contains header information
	A Body element that contains call and response information
	A Fault element containing errors and status information
	
  RESTful web services:
  	
	 Restful service would use the normal HTTP verbs of GET, POST, PUT and DELETE for working with the required components
	
	 Stateless

	 Lack of Security
	
	 Representational State Transfer
 
 	 Resource - Collections - URL

   	 resource should always be plural

   	 Sorting, filterning, searching, pagination, version set
	
  SOAP is a protocol whereas REST is an architectural pattern.
  
  WDSL:
  
  Create soap api by wsdl :
  
  
<types>		Defines data types
<message>	Defines the data elements (main message)
<portType>	communication level
<binding>	this is the param for add with soap protocal




Katalon Studio is a free-license tool released in January 2015 with a Selenium-based engine. 
Mostly, Katalon is designed to create and reuse automated test scripts for UI without coding


