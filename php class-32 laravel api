API CREATE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


View:

Route::get('departments', function() {
    
    $department = department::all();
    if(count($department) == 0){
       $feedback = [
           'status'     => "error",
           'message'    => "data not found",
           'data'       => null
        ]; 
       
    }else{
        $feedback = [
           'status'     => "success",
           'message'    => "data found",
           'data'       => $department
        ]; 
    }
    
    return $feedback;
    
});


______

Edit:

Route::get('departments/{id}', function($id) 

create method for edit

______

Post:

Route::post('departments', function(Request $request) {

    $data = $request->all();
    
    return ap::create([
        'name' => $data['name']
    ]);

    if(count($data) == 0){
       $feedback = [
           'status'     => "error",
           'message'    => "insert error"
        ]; 

    }else{
        $feedback = [
           'status'     => "success",
           'message'    => "inserted successfully"
        ]; 
    }
    
});

** must add 

protected $fillable = ['fieldname','fieldname']


______


Update :

Route::put('poll/{id}','control@method')


controller :

public function update(Request $request,$id) {

   $poll = DB::table('aps')
		->where('id',$id)
		->update(array(
			'name'=>$request->name,
		));

   if($poll == null){
       $feedback = [
	   'status'     => "error",
	   'message'    => "update error"
	]; 

    }else{
	$feedback = [
	   'status'     => "success",
	   'message'    => "update successfully"
	]; 
    }

    return $feedback;

}



______



Delete :


Route::delete('poll/{id}','control@method')

controller :

public function delete(Request $request,$id) {

   $poll = DB::table('aps')
		->where('id',$id)
		->delete();

   if($poll == null){
       $feedback = [
	   'status'     => "error",
	   'message'    => "delete error"
	]; 

    }else{
	$feedback = [
	   'status'     => "success",
	   'message'    => "delete successfully"
	]; 
    }

    return $feedback;

}



::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



Validation for view:

$department = department::find($id);

if(is_null(ap::find($id))){
    $feedback = [
       'status'     => "error",
       'message'    => "data not found",
       'data'       => null
    ]; 
    return $feedback;
}else{
    $feedback = [
       'status'     => "success",
       'message'    => "data found",
       'data'       => ap::find($id)
    ]; 
    return $feedback;
}


Validation for insert:


$validator = Validator::make($request->all(), [
	        
    'name'  => 'required'

]);

if ($validator->fails()) {

    return response()->json($validator->errors()->toArray(),400);
    
} else {

    $data = $request->all();
    return ap::create([
        'name' => $data['name']
    ]);

    if(count($data) == 0){
       $feedback = [
           'status'     => "error",
           'message'    => "insert error"
        ]; 

    }else{
        $feedback = [
           'status'     => "success",
           'message'    => "inserted successfully"
        ]; 
    }
}




::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CUSTOMIZE SINGLE API RESPONSE DATA:


			    modelname / modelnameCollection

* php artisan make:resource Product / ProductCollection


Show method for single data 

* use App\Http\Resources\Product\ProductResource;
  
* return new ProductResource($product); 
 
 
Customize property of API :
	
		   
public function toArray($request){

	return [

	'name' => $this->name,

	'stock'	=> count($this->stock) == 0 ? 'out_of_stoke' : $this->stock,

	'href'=> 
		[	
		  'details' => route('products.show',$this->id)
		]

	];
}




CUSTOMIZE ALL API RESPONSE DATA:


* php artisan make:resource crud/crudCollection

* set in crudCollection:

use Illuminate\Http\Resources\Json\Resource;

class crudCollection extends Resource

* set in method:

crudCollection::collection(crud::all())






::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


Side loading | one to many relationship:

side load is load foreign key data in api.
like load all questions of a poll.

in poll model:

public function questions(){
  return hasMany('App\Quesion');
}


in poll controller:

public function show($id){

  $poll = Poll::with('questions')->findOrFail($id);
  $response['poll'] = $poll;
  $response['questions'] = $poll->questions;
  return response->json($response,200);
  
}



::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 


Paginate API :

department::paginate(10);




::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 


API File show:

return response->download(asset('imgae/a.png','Show name here'));

see header response for file details.


API File upload:

$image = $request->file('photo')->store('image');

return response()->json(['path' => $path], 200);



::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

 
Guzzle Token Check:

************

Client request for access API data:

Route::get('Developerall','DeveloperController@getGuzzleRequest');

---

use GuzzleHttp\Client;

public function getGuzzleRequest(){
	$client = new Client(['http_errors' => false]);
	$allresponse = $client->request('GET','http://localhost/meeting_apps/public/api/departments', [
	    'headers' => [
		'authorization' => "after login set random token here & update token in database"
	    ]
	]);
	$allbody = $allresponse->getBody();
	$all_list = json_decode($allbody->getContents());
	return view('view',compact('all_list'));

}
    
************

Create API & Client auth check:

Use GuzzleHttp\Client;
use Illuminate\Http\Request;

Route::get('departments', function(Request $request) {
    
    $headers = $request->headers->all(); 
    // full array
    
    $pubapi = $request->header('authorization'); 
    // only token
    // now check token exits in table or not
    // if token exits then pass data.
    
    $department = Department::all();
    if(count($department) == 0){
       $feedback = [
           'status'     => "error",
           'message'    => "data not found",
           'data'       => null
        ]; 
    }else{
        $feedback = [
           'status'     => "success",
           'message'    => "data found",
           'data'       => $department
        ]; 
    }
    return $department;
});

___

View data :


@foreach($alldata as $alldatas)

    {{ $alldatas['name'] }}
    
@endforeach


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 
 
 Oauth:
 
 1. Login then Creating an App, insert data in oauth_clients
 	
	-> users:
	
	1. username
	2. password
	3. email
	4. empUserId
	5. pic
	6. dob
	7. phone
	
	* The Authorization Server:
	
	-> oauth_clients:
	
	1. empUserId 
	2. website name 
	3. callbackurl  		(URIs beginning with "https")
	4. oauth_clients     		(client id)
	5. oauth_client_secret		(client secret)
	5. oauth_auth_codes  		(send to apps after client accept request)
	8. oauth_access_tokens		(send if client id & secret match)
	9. grant types 			(different use cases)
 	
	* Resource Server (Resource table):
	
	-> resource data from users table if
	   
	1. access_permission
	2. empUserId
	3. access_token 		(at last if access token match send data)
		
	
 2. login with facebook button:.
 
	https://authorization-server.com/auth?response_type=code&client_id=CLIENT_ID&redirect_uri=example-app.com&state=1234zyx
	
	response_type	=code - Indicates that your server expects to receive an authorization code
	client_id 	- The client ID you received when you first created the application
	redirect_uri 	- Indicates the URI to return the user to after authorization is complete
	state 		- A random string generated by your application
 
 3. After login gives a confirmation message If the user clicks "Allow," the service redirects the user back to your site 
    with an auth code
    
    https://example-app.com/cb?code=oauth_auth_codes&state=1234zyx
    
    
    code - The server returns the authorization code in the query string from oauth_auth_codes column
    state - The server returns the same state value that you passed

 4. You should first compare this state value to ensure it matches the one you started with.
    You can typically store the state value in a cookie or session, and compare it when the user comes back.
    This ensures your redirection endpoint isn't able to be tricked into attempting to exchange arbitrary authorization codes.
    
 5. if ok send this request:
    POST https://api.authorization-server.com/token
	  grant_type=authorization_code&
	  code=AUTH_CODE_HERE&
	  redirect_uri=REDIRECT_URI&
	  client_id=CLIENT_ID&
	  client_secret=CLIENT_SECRET
	  

	
    grant_type		= authorization_code - The grant type for this flow is authorization_code
    code		= AUTH_CODE_HERE - This is the code you received in the query string
    redirect_uri	= REDIRECT_URI - Must be identical to the redirect URI provided in the original link
    client_id		= CLIENT_ID - The client ID you received when you first created the application
    client_secret	= CLIENT_SECRET - Since this request is made from server-side code, the secret is included

 4. The server replies with an access token and expiration time
    
     {
	  "access_token":"RsT5OjbzRn430zqMLgV3Ia",
	  "expires_in":3600
     }
     
     
 
 
SETPs:

1. Register app_user
2. Register app_user in oauth_clients section
3. Provide register apps_user oauth_clients information & login link
4. after hit login link by apps view a login link
5. after login successfully ask for grant permission
6. after grant response same api a oauth_auth_codes & state code
7. now only check state value if ok send full information
        POST https://api.authorization-server.com/token
	  grant_type=authorization_code&
	  code=AUTH_CODE_HERE&
	  redirect_uri=REDIRECT_URI&
	  client_id=CLIENT_ID&
	  client_secret=CLIENT_SECRET
8. if ok send access_token in same api
9. now hit with access token in same api


